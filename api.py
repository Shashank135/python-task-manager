# api.py
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Optional

app = FastAPI()

# Pydantic model for a Task
class Task(BaseModel):
    id: Optional[int] = None # ID will be generated by the API
    title: str
    done: bool = False

# In-memory "database" for tasks
tasks_db = []
task_id_counter = 1

@app.get("/", tags=["Root"])
async def read_root():
    return {"message": "Welcome to the Simple Task API! Use /tasks endpoint or /docs for API documentation."}

@app.get("/tasks", response_model=List[Task], tags=["Tasks"])
async def get_tasks():
    return tasks_db

@app.post("/tasks", response_model=Task, status_code=201, tags=["Tasks"])
async def create_task(task: Task):
    global task_id_counter
    if not task.title:
        raise HTTPException(status_code=400, detail="Title is required")

    new_task = task.model_dump() # Convert Pydantic model to dict
    new_task["id"] = task_id_counter
    tasks_db.append(new_task)
    task_id_counter += 1
    return new_task

@app.get("/tasks/{task_id}", response_model=Task, tags=["Tasks"])
async def get_task(task_id: int):
    task = next((t for t in tasks_db if t["id"] == task_id), None)
    if task is None:
        raise HTTPException(status_code=404, detail="Task not found")
    return task

@app.delete("/tasks/{task_id}", status_code=200, tags=["Tasks"])
async def delete_task(task_id: int):
    global tasks_db
    initial_len = len(tasks_db)
    tasks_db = [t for t in tasks_db if t["id"] != task_id]
    if len(tasks_db) == initial_len:
        raise HTTPException(status_code=404, detail="Task not found")
    return {"message": "Task deleted successfully"}

# You can explore PUT/PATCH methods for updating tasks later if you like.